import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,f as e,a as i,o as p}from"./app-DkeCzSGI.js";const l={};function d(t,s){return p(),a("div",null,[s[0]||(s[0]=e(`<h1 id="幽灵依赖问题" tabindex="-1"><a class="header-anchor" href="#幽灵依赖问题"><span>幽灵依赖问题</span></a></h1><h4 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h4><p>幽灵依赖（Phantom Dependency）指的是：一个包可以使用它的祖先依赖（祖先的 node_modules 里的包），即使它自己没有在 package.json 中声明该依赖。</p><p>这种情况通常发生在 npm 和 yarn 采用的**Hoisting（依赖提升）**策略下，导致某些包在 node_modules 目录中可访问，但其实不应该被访问。</p><p>⸻</p><h4 id="_1-为什么会产生幽灵依赖" tabindex="-1"><a class="header-anchor" href="#_1-为什么会产生幽灵依赖"><span>1. 为什么会产生幽灵依赖？</span></a></h4><p>在 npm 和 yarn 的默认 node_modules 结构中，依赖会被“提升”（hoist）到上级目录的 node_modules 中，以减少重复安装。例如：</p><p>示例</p><p>假设 package.json 这样定义：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;dependencies&quot;: {</span></span>
<span class="line"><span>    &quot;A&quot;: &quot;^1.0.0&quot;,</span></span>
<span class="line"><span>    &quot;B&quot;: &quot;^1.0.0&quot;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>• A 依赖于 lodash，但 B 并不依赖 lodash。<br> ​ • 在 npm 或 yarn 的 hoisting 机制下，可能会将 lodash 提升到 node_modules/ 目录的根目录。</p><p>目录结构可能变成这样：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/node_modules</span></span>
<span class="line"><span>  /A</span></span>
<span class="line"><span>    /node_modules</span></span>
<span class="line"><span>      lodash/  (← 可能不会出现在这里)</span></span>
<span class="line"><span>  /B</span></span>
<span class="line"><span>  lodash/  (← 被提升到顶层)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>问题：</p><p>B 本来没有依赖 lodash，但它仍然可以直接 require(&#39;lodash&#39;)，因为 lodash 被提升到了顶层 node_modules/，而 Node.js 依赖解析规则会向上查找。</p>`,15)),i(" more "),s[1]||(s[1]=e(`<p>⸻</p><h4 id="_2-为什么幽灵依赖是个问题" tabindex="-1"><a class="header-anchor" href="#_2-为什么幽灵依赖是个问题"><span>2. 为什么幽灵依赖是个问题？</span></a></h4><p>幽灵依赖会导致代码在某些环境下正常运行，在其他环境下报错，因为依赖项的可用性取决于 node_modules 的结构，而 node_modules 的结构可能因不同的安装方式而变化。</p><p>主要风险：<br> • 代码不可预测：依赖项不是显式声明的，某些机器上可能找得到，某些机器上可能找不到。<br> • 团队协作问题：如果一个开发者无意中使用了幽灵依赖，其他开发者（或 CI/CD 服务器）可能会遇到 Cannot find module 错误。<br> • 升级破坏性：如果 A 更新了，可能 lodash 版本变化或者不再依赖 lodash，但 B 仍然错误地依赖它，导致 B 在某些情况下崩溃。</p><p>⸻</p><h4 id="_3-如何避免幽灵依赖" tabindex="-1"><a class="header-anchor" href="#_3-如何避免幽灵依赖"><span>3. 如何避免幽灵依赖？</span></a></h4><p>✅ 方法 1：使用 pnpm</p><p>pnpm 不会 hoist 依赖，它使用严格的模块隔离，每个包只能访问自己的依赖。例如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/node_modules</span></span>
<span class="line"><span>  /.pnpm</span></span>
<span class="line"><span>    A@1.0.0/</span></span>
<span class="line"><span>      node_modules/</span></span>
<span class="line"><span>        lodash/</span></span>
<span class="line"><span>    B@1.0.0/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 pnpm 下，B 无法 访问 lodash，如果 B 试图 require(&#39;lodash&#39;)，会报错，除非它自己显式安装 lodash。</p><p>⸻</p><p>✅ 方法 2：在 package.json 显式声明所有依赖</p><p>如果一个包需要 lodash，就应该在自己的 package.json 中添加：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;dependencies&quot;: {</span></span>
<span class="line"><span>    &quot;lodash&quot;: &quot;^4.17.21&quot;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样无论 npm 还是 yarn，都不会依赖提升带来的不确定性。</p><p>⸻</p><p>✅ 方法 3：使用 --strict-peer-deps 选项</p><p>在 npm 或 yarn 里，你可以使用：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>npm install --strict-peer-deps</span></span>
<span class="line"><span>yarn install --check-files</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样如果有未声明的依赖，安装时就会报错。</p><p>⸻</p><p>✅ 方法 4：使用 npm dedupe 或 yarn-deduplicate</p><p>如果怀疑 node_modules 里有幽灵依赖，可以运行：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>npm dedupe</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>或者：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>yarn-deduplicate</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>清理依赖，重新安装。</p><p>⸻</p><h4 id="结论" tabindex="-1"><a class="header-anchor" href="#结论"><span>结论</span></a></h4><p>• npm 和 yarn 默认可能会导致幽灵依赖，因为它们的 hoisting 机制可能让某些包“意外可用”。<br> ​ • pnpm 不会出现幽灵依赖，因为它有严格的依赖隔离。<br> ​ • 避免幽灵依赖的最佳做法是显式声明所有依赖，并使用 --strict-peer-deps 或 pnpm 进行严格管理。</p><p>如果团队经常遇到幽灵依赖问题，建议迁移到 pnpm。</p>`,31))])}const c=n(l,[["render",d]]),h=JSON.parse(`{"path":"/posts/%E5%85%B6%E4%BB%96/%E5%B9%BD%E7%81%B5%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98.html","title":"幽灵依赖问题","lang":"zh-CN","frontmatter":{"icon":"file-contract","date":"2025-01-12T00:00:00.000Z","category":["前端"],"tag":["工程化"],"description":"前言 幽灵依赖（Phantom Dependency）指的是：一个包可以使用它的祖先依赖（祖先的 node_modules 里的包），即使它自己没有在 package.json 中声明该依赖。 这种情况通常发生在 npm 和 yarn 采用的**Hoisting（依赖提升）**策略下，导致某些包在 node_modules 目录中可访问，但其实不应该被...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"幽灵依赖问题\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-01-12T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-28T09:19:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.ws\\",\\"url\\":\\"https://exploreoo.github.io/\\",\\"email\\":\\"3351550900@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://exploreoo.github.io/posts/%E5%85%B6%E4%BB%96/%E5%B9%BD%E7%81%B5%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"WSPACE"}],["meta",{"property":"og:title","content":"幽灵依赖问题"}],["meta",{"property":"og:description","content":"前言 幽灵依赖（Phantom Dependency）指的是：一个包可以使用它的祖先依赖（祖先的 node_modules 里的包），即使它自己没有在 package.json 中声明该依赖。 这种情况通常发生在 npm 和 yarn 采用的**Hoisting（依赖提升）**策略下，导致某些包在 node_modules 目录中可访问，但其实不应该被..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-28T09:19:21.000Z"}],["meta",{"property":"article:tag","content":"工程化"}],["meta",{"property":"article:published_time","content":"2025-01-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-28T09:19:21.000Z"}]]},"git":{"createdTime":1746970362000,"updatedTime":1756372761000,"contributors":[{"name":"exploreoo","username":"exploreoo","email":"1848820553@qq.com","commits":1,"url":"https://github.com/exploreoo"},{"name":"wangshuang70","username":"wangshuang70","email":"wangshuang70@meicloud.com","commits":4,"url":"https://github.com/wangshuang70"}]},"readingTime":{"minutes":2.72,"words":816},"filePathRelative":"posts/其他/幽灵依赖问题.md","excerpt":"\\n<h4>前言</h4>\\n<p>幽灵依赖（Phantom Dependency）指的是：一个包可以使用它的祖先依赖（祖先的 node_modules 里的包），即使它自己没有在 package.json 中声明该依赖。</p>\\n<p>这种情况通常发生在 npm 和 yarn 采用的**Hoisting（依赖提升）**策略下，导致某些包在 node_modules 目录中可访问，但其实不应该被访问。</p>\\n<p>⸻</p>\\n<h4>1. 为什么会产生幽灵依赖？</h4>\\n<p>在 npm 和 yarn 的默认 node_modules 结构中，依赖会被“提升”（hoist）到上级目录的 node_modules 中，以减少重复安装。例如：</p>\\n<p>示例</p>\\n<p>假设 package.json 这样定义：</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>{</span></span>\\n<span class=\\"line\\"><span>  \\"dependencies\\": {</span></span>\\n<span class=\\"line\\"><span>    \\"A\\": \\"^1.0.0\\",</span></span>\\n<span class=\\"line\\"><span>    \\"B\\": \\"^1.0.0\\"</span></span>\\n<span class=\\"line\\"><span>  }</span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><p>• A 依赖于 lodash，但 B 并不依赖 lodash。<br>\\n​ • 在 npm 或 yarn 的 hoisting 机制下，可能会将 lodash 提升到 node_modules/ 目录的根目录。</p>\\n<p>目录结构可能变成这样：</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>/node_modules</span></span>\\n<span class=\\"line\\"><span>  /A</span></span>\\n<span class=\\"line\\"><span>    /node_modules</span></span>\\n<span class=\\"line\\"><span>      lodash/  (← 可能不会出现在这里)</span></span>\\n<span class=\\"line\\"><span>  /B</span></span>\\n<span class=\\"line\\"><span>  lodash/  (← 被提升到顶层)</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><p>问题：</p>\\n<p>B 本来没有依赖 lodash，但它仍然可以直接 require('lodash')，因为 lodash 被提升到了顶层 node_modules/，而 Node.js 依赖解析规则会向上查找。</p>\\n","autoDesc":true}`);export{c as comp,h as data};
