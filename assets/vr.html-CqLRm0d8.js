import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,f as i,a as e,o as n}from"./app-6tg6kd_l.js";const h={};function d(l,t){return n(),a("div",null,[t[0]||(t[0]=i('<h1 id="框架选型设计-vue-react" tabindex="-1"><a class="header-anchor" href="#框架选型设计-vue-react"><span>框架选型设计（vue/react）</span></a></h1><h2 id="_1-设计理念" tabindex="-1"><a class="header-anchor" href="#_1-设计理念"><span>1. 设计理念</span></a></h2><table><thead><tr><th>特性</th><th>Vue</th><th>React</th></tr></thead><tbody><tr><td>定位</td><td>渐进式框架</td><td>UI 库</td></tr><tr><td>编程范式</td><td>选项式（Option API） + 组合式（Composition API）</td><td>函数式</td></tr><tr><td>架构设计</td><td>内聚（内建路由、状态管理）</td><td>解耦（核心只管视图，其他靠社区）</td></tr><tr><td>组件形式</td><td>vue文件（模板 + JS）</td><td>JSX（JS + XML）</td></tr></tbody></table><p>Vue 更强调易用性和渐进增强，适合快速开发。其内置了黑魔法，例如：SFC、宏函数、指令、scoped等；</p><p>React 更强调灵活性和函数式编程，更适合复杂业务需求。</p>',5)),e(" more "),t[1]||(t[1]=i(`<hr><h2 id="_2-响应式系统" tabindex="-1"><a class="header-anchor" href="#_2-响应式系统"><span>2. 响应式系统</span></a></h2><h3 id="vue-基于-proxy-的响应式系统" tabindex="-1"><a class="header-anchor" href="#vue-基于-proxy-的响应式系统"><span>Vue：基于 Proxy 的响应式系统</span></a></h3><p>Vue 3 引入 Proxy 作为响应式核心，实现了更高效的依赖追踪与自动更新。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> state</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> reactive</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">({ </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">count</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">watchEffect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">state</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>属性级追踪</strong>响应依赖，更新粒度更细；</li><li>响应式核心独立（@vue/reactivity 可单独使用）</li></ul><h3 id="react-基于-hooks-的状态管理" tabindex="-1"><a class="header-anchor" href="#react-基于-hooks-的状态管理"><span>React：基于 Hooks 的状态管理</span></a></h3><p>React 的响应式依赖于状态更新机制，通过 <code>useState</code> 和 <code>useEffect</code> 控制组件更新。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">setCount</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">useEffect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}, [</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>虚拟 DOM 全量 Diff，依赖手动优化（如 <code>React.memo</code>），状态更新触发组件函数整体重新执行</li><li>副作用管理需要开发者显式控制</li></ul><hr><h2 id="_3-优化" tabindex="-1"><a class="header-anchor" href="#_3-优化"><span>3. 优化</span></a></h2><ul><li><p>Vue 使用模板编译生成的 VNode，通过 patchFlag 和静态提升优化 DOM diff 性能：</p><ul><li><p>编译时优化：静态节点只生成一次；</p></li><li><p>PatchFlag 提高渲染效率；</p></li><li><p>更新更具针对性，Diff 更细粒度；</p></li></ul></li><li><p>React 16 引入 Fiber 架构，实现了异步可中断渲染：</p><ul><li><p>可中断更新任务，避免卡顿；</p></li><li><p>支持优先级调度（React Scheduler）；</p></li><li><p>适配 Concurrent Mode，支持时间切片；</p></li></ul></li></ul><hr><h2 id="_4-生态系统与社区对比" tabindex="-1"><a class="header-anchor" href="#_4-生态系统与社区对比"><span>4. 生态系统与社区对比</span></a></h2><table><thead><tr><th>项目类型</th><th>Vue</th><th>React</th></tr></thead><tbody><tr><td>路由管理</td><td>vue-router（官方）</td><td>react-router（社区）</td></tr><tr><td>状态管理</td><td>Vuex / Pinia（官方）</td><td>Redux / Recoil / Zustand（社区）</td></tr><tr><td>构建工具</td><td>Vite / Vue CLI</td><td>Create React App / Vite / Next.js</td></tr><tr><td>SSR 支持</td><td>Nuxt.js</td><td>Next.js</td></tr></tbody></table><p>React 在全球范围内生态更庞大，尤其在服务器端渲染、构建系统上领先一步。而 Vue 在国内拥有强大的社区支持，官方生态整合度高，上手快、迭代快。</p><hr><h2 id="_5-性能与优化对比" tabindex="-1"><a class="header-anchor" href="#_5-性能与优化对比"><span>5. 性能与优化对比</span></a></h2><table><thead><tr><th>场景</th><th>优势者</th><th>原因</th></tr></thead><tbody><tr><td>首屏渲染速度</td><td>Vue</td><td>模板静态提升优化明显</td></tr><tr><td>局部状态更新</td><td>Vue</td><td>Proxy + 属性级依赖追踪</td></tr><tr><td>并发任务处理</td><td>React</td><td>Fiber 架构更适合任务调度</td></tr><tr><td>大型应用可维护性</td><td>React</td><td>函数式架构更利于分层与解耦</td></tr></tbody></table><hr><h2 id="_6-选型建议" tabindex="-1"><a class="header-anchor" href="#_6-选型建议"><span>6. 选型建议</span></a></h2><h3 id="选择-vue" tabindex="-1"><a class="header-anchor" href="#选择-vue"><span>选择 Vue：</span></a></h3><ul><li>需要快速上线、团队偏向传统开发方式</li><li>更重视开发效率而非极致性能</li></ul><h3 id="选择-react" tabindex="-1"><a class="header-anchor" href="#选择-react"><span>选择 React：</span></a></h3><ul><li>项目规模较大、技术架构需高度定制</li><li>团队具备 TS、函数式编程经验</li><li>需要支持并发渲染、渐进式加载、高性能动画等复杂场景</li></ul>`,26))])}const o=s(h,[["render",d]]),c=JSON.parse('{"path":"/posts/%E6%A1%86%E6%9E%B6/vr.html","title":"框架选型设计（vue/react）","lang":"zh-CN","frontmatter":{"icon":"file-contract","date":"2024-08-02T00:00:00.000Z","category":["前端","vue","React"],"tag":["框架","vue","React"],"description":"1. 设计理念 Vue 更强调易用性和渐进增强，适合快速开发。其内置了黑魔法，例如：SFC、宏函数、指令、scoped等； React 更强调灵活性和函数式编程，更适合复杂业务需求。","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"框架选型设计（vue/react）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-02T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-29T03:38:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.ws\\",\\"url\\":\\"https://exploreoo.github.io/\\",\\"email\\":\\"3351550900@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://exploreoo.github.io/posts/%E6%A1%86%E6%9E%B6/vr.html"}],["meta",{"property":"og:site_name","content":"WSPACE"}],["meta",{"property":"og:title","content":"框架选型设计（vue/react）"}],["meta",{"property":"og:description","content":"1. 设计理念 Vue 更强调易用性和渐进增强，适合快速开发。其内置了黑魔法，例如：SFC、宏函数、指令、scoped等； React 更强调灵活性和函数式编程，更适合复杂业务需求。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-29T03:38:55.000Z"}],["meta",{"property":"article:tag","content":"React"}],["meta",{"property":"article:tag","content":"vue"}],["meta",{"property":"article:tag","content":"框架"}],["meta",{"property":"article:published_time","content":"2024-08-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-29T03:38:55.000Z"}]]},"git":{"createdTime":1746970362000,"updatedTime":1756438735000,"contributors":[{"name":"exploreoo","username":"exploreoo","email":"1848820553@qq.com","commits":1,"url":"https://github.com/exploreoo"},{"name":"wangshuang70","username":"wangshuang70","email":"wangshuang70@meicloud.com","commits":8,"url":"https://github.com/wangshuang70"}]},"readingTime":{"minutes":2.44,"words":732},"filePathRelative":"posts/框架/vr.md","excerpt":"\\n<h2>1. 设计理念</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>特性</th>\\n<th>Vue</th>\\n<th>React</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>定位</td>\\n<td>渐进式框架</td>\\n<td>UI 库</td>\\n</tr>\\n<tr>\\n<td>编程范式</td>\\n<td>选项式（Option API） + 组合式（Composition API）</td>\\n<td>函数式</td>\\n</tr>\\n<tr>\\n<td>架构设计</td>\\n<td>内聚（内建路由、状态管理）</td>\\n<td>解耦（核心只管视图，其他靠社区）</td>\\n</tr>\\n<tr>\\n<td>组件形式</td>\\n<td>vue文件（模板 + JS）</td>\\n<td>JSX（JS + XML）</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>Vue 更强调易用性和渐进增强，适合快速开发。其内置了黑魔法，例如：SFC、宏函数、指令、scoped等；</p>\\n<p>React 更强调灵活性和函数式编程，更适合复杂业务需求。</p>\\n","autoDesc":true}');export{o as comp,c as data};
