import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,f as n,o}from"./app-DkeCzSGI.js";const i={};function p(l,e){return o(),t("div",null,e[0]||(e[0]=[n('<h1 id="observer-api" tabindex="-1"><a class="header-anchor" href="#observer-api"><span>Observer API</span></a></h1><ul><li><p><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener noreferrer">IntersectionObserver</a></strong></p><p>过去，相交检测通常要用到事件监听，并且需要频繁调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noopener noreferrer"><code>Element.getBoundingClientRect()</code></a> 方法以获取相关元素的边界信息。事件监听和调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noopener noreferrer"><code>Element.getBoundingClientRect()</code></a> 都是在主线程上运行，因此频繁触发、调用可能会造成性能问题。这种检测方法极其怪异且不优雅。</p><p>Intersection Observer API 会注册一个回调函数，每当被监视的元素进入或者退出另外一个元素时 (或者 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport" target="_blank" rel="noopener noreferrer">viewport</a> )，或者两个元素的相交部分大小发生变化时，该回调方法会被触发执行。这样，我们网站的主线程不需要再为了监听元素相交而辛苦劳作，浏览器会自行优化元素相交管理。</p><p>应用场景：</p><ul><li>图片懒加载——当图片滚动到可见时才进行加载</li></ul></li><li><p>内容无限滚动——也就是用户滚动到接近内容底部时直接加载更多，而无需用户操作翻页，给用户一种网页可以无限滚动的错觉</p><ul><li>检测广告的曝光情况——为了计算广告收益，需要知道广告元素的曝光情况</li><li>在用户看见某个区域时执行任务或播放动画</li></ul></li><li><p><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener noreferrer">MutationObserver</a></strong></p><p>监听一个普通 JS 对象的变化，我们会用 Object.defineProperty 或者 Proxy。</p><p>监听元素属性和子节点变化，比如可以用来做去不掉的水印。MutationObserver 可以监听对元素的属性的修改、对它的子节点的增删改</p></li><li><p><strong>ResizeObserver</strong></p><p>窗口我们可以用 addEventListener 监听 resize 事件。</p><p>监听元素大小变化。使用 ResizeObserver 监听大小的改变，当 width、height 被修改时会触发回调</p></li><li><p><strong>PerformanceObserver</strong></p><p>PerformanceObserver 用于监听记录 performance 数据的行为。一旦记录了就会触发回调，这样我们就可以在回调里把这些数据上报</p></li><li><p><strong>ReportingObserver</strong></p><p>可以保证更全面的了解网页 app 的运行情况。ReportingObserver 可以监听过时的 api、浏览器干预等报告等的打印，在回调里上报，这些是错误监听无法监听到但对了解网页运行情况很有用的数据</p></li></ul>',2)]))}const c=r(i,[["render",p]]),g=JSON.parse('{"path":"/posts/%E5%85%B6%E4%BB%96/observerAPI.html","title":"Observer API","lang":"zh-CN","frontmatter":{"icon":"file-contract","date":"2023-10-15T00:00:00.000Z","category":["前端"],"tag":["web-api"],"description":"Observer API IntersectionObserver 过去，相交检测通常要用到事件监听，并且需要频繁调用 Element.getBoundingClientRect() 方法以获取相关元素的边界信息。事件监听和调用 Element.getBoundingClientRect() 都是在主线程上运行，因此频繁触发、调用可能会造成性能问题。这...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Observer API\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-15T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-28T09:19:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.ws\\",\\"url\\":\\"https://exploreoo.github.io/\\",\\"email\\":\\"3351550900@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://exploreoo.github.io/posts/%E5%85%B6%E4%BB%96/observerAPI.html"}],["meta",{"property":"og:site_name","content":"WSPACE"}],["meta",{"property":"og:title","content":"Observer API"}],["meta",{"property":"og:description","content":"Observer API IntersectionObserver 过去，相交检测通常要用到事件监听，并且需要频繁调用 Element.getBoundingClientRect() 方法以获取相关元素的边界信息。事件监听和调用 Element.getBoundingClientRect() 都是在主线程上运行，因此频繁触发、调用可能会造成性能问题。这..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-28T09:19:21.000Z"}],["meta",{"property":"article:tag","content":"web-api"}],["meta",{"property":"article:published_time","content":"2023-10-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-28T09:19:21.000Z"}]]},"git":{"createdTime":1746970362000,"updatedTime":1756372761000,"contributors":[{"name":"exploreoo","username":"exploreoo","email":"1848820553@qq.com","commits":1,"url":"https://github.com/exploreoo"},{"name":"wangshuang70","username":"wangshuang70","email":"wangshuang70@meicloud.com","commits":4,"url":"https://github.com/wangshuang70"}]},"readingTime":{"minutes":1.93,"words":578},"filePathRelative":"posts/其他/observerAPI.md","excerpt":"\\n<ul>\\n<li>\\n<p><strong><a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">IntersectionObserver</a></strong></p>\\n<p>过去，相交检测通常要用到事件监听，并且需要频繁调用 <a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>Element.getBoundingClientRect()</code></a> 方法以获取相关元素的边界信息。事件监听和调用 <a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>Element.getBoundingClientRect()</code></a> 都是在主线程上运行，因此频繁触发、调用可能会造成性能问题。这种检测方法极其怪异且不优雅。</p>\\n<p>Intersection Observer API 会注册一个回调函数，每当被监视的元素进入或者退出另外一个元素时 (或者 <a href=\\"https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">viewport</a> )，或者两个元素的相交部分大小发生变化时，该回调方法会被触发执行。这样，我们网站的主线程不需要再为了监听元素相交而辛苦劳作，浏览器会自行优化元素相交管理。</p>\\n<p>应用场景：</p>\\n<ul>\\n<li>图片懒加载——当图片滚动到可见时才进行加载</li>\\n</ul>\\n</li>\\n<li>\\n<p>内容无限滚动——也就是用户滚动到接近内容底部时直接加载更多，而无需用户操作翻页，给用户一种网页可以无限滚动的错觉</p>\\n<ul>\\n<li>检测广告的曝光情况——为了计算广告收益，需要知道广告元素的曝光情况</li>\\n<li>在用户看见某个区域时执行任务或播放动画</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong><a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">MutationObserver</a></strong></p>\\n<p>监听一个普通 JS 对象的变化，我们会用 Object.defineProperty 或者 Proxy。</p>\\n<p>监听元素属性和子节点变化，比如可以用来做去不掉的水印。MutationObserver 可以监听对元素的属性的修改、对它的子节点的增删改</p>\\n</li>\\n<li>\\n<p><strong>ResizeObserver</strong></p>\\n<p>窗口我们可以用 addEventListener 监听 resize 事件。</p>\\n<p>监听元素大小变化。使用 ResizeObserver 监听大小的改变，当 width、height 被修改时会触发回调</p>\\n</li>\\n<li>\\n<p><strong>PerformanceObserver</strong></p>\\n<p>PerformanceObserver 用于监听记录 performance 数据的行为。一旦记录了就会触发回调，这样我们就可以在回调里把这些数据上报</p>\\n</li>\\n<li>\\n<p><strong>ReportingObserver</strong></p>\\n<p>可以保证更全面的了解网页 app 的运行情况。ReportingObserver 可以监听过时的 api、浏览器干预等报告等的打印，在回调里上报，这些是错误监听无法监听到但对了解网页运行情况很有用的数据</p>\\n</li>\\n</ul>","autoDesc":true}');export{c as comp,g as data};
